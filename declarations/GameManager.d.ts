declare interface GameManager {

    account: string;
    captureZoneGenerator: CaptureZoneGenerator;
    contractConstants: Record<string, any>;
    contractsAPI: any /* ContractsAPI */;
    diagnostics: {
        callsInQueue: number;
        chunkUpdates: number;
        df_event_type: "diagnostics"
        fps: number;
        gasPrices: {
            average: number;
            fast: number;
            slow: number;
        };
        height: number;
        rpcUrl: string;
        totalCalls: number;
        totalChunks: number;
        totalPlanets: number;
        totalTransactions: number;
        transactionsInQueue: number;
        visibleChunks: number;
        visiblePlanets: number;
        width: number;
    };
    diagnosticsInterval: number;
    endTimeSeconds: number;
    entityStore: GameObjects;
    ethConnection: EthConnection;
    hashConfig: HashConfig;
    hashRate: number;
    homeLocation: WorldLocation;
    minerManager?: any /** MinerManager */;
    paused: boolean;
    paused$: Monomitter<boolean>;
    persistentChunkStore: PersistentChunkStore;
    planetHashMimc: (...inputs: number[]) => TBigInteger;
    playerInterval: ReturnType<typeof setInterval>;
    players: Map<string, Player>;
    playersUpdated$: Monomitter<void>;
    safeMode: boolean;
    scoreboardInterval: ReturnType<typeof setInterval>;
    snarkHelper: SnarkHelper;
    terminal: MutableRefObject<TerminalHandle>;
    useMockHash: boolean;
    worldRadius: number;

    get planetRarity(): number;

    addAccount(coords: WorldCoords): Promise<boolean>;
    addNewChunk(chunk: Chunk): GameManager;
    biomeBasePerlin(coords: WorldCoords, floor: boolean): number;
    bulkAddNewChunks(chunks: Chunk[]): Promise<void>;
    bulkHardRefreshPlanets(planetIds: LocationId[]): Promise<void>;
    checkGameHasEnded(): boolean;
    clearEmoij(location: LocationId): Promise<void>;
    destroy(): void;
    findRandomHomePlanet(): Promise<LocatablePlanet>;
    forceTick(location: LocationId): void;
    getAccount(): string;
    getActivateArtifact(location: LocationId): Artifact;
    getAddress(): string;
    getAllOwnedPlanets(): Planet[];
    getAllPlanets(): Iterable<Planet>;
    getAllPlayers(): Player[];
    getAllVoyages(): QueuedArrival[];
    getArtifactMap(): Map<ArtifactId, Artifact>;
    getArtifactUpdated$(): Monomitter<ArtifactId>;
    getArtifactWithId(artifactId: ArtifactId): Artifact;
    getArtifactWithIds(artifactIds: ArtifactId[]): Artifact[];
    getCaptureZoneGenerator(): CaptureZoneGenerator;
    getCaptureZones(): Set<CaptureZone>;
    getChunk(chunkFootprint: Rectangle): Chunk;
    getChunkStore(): PersistentChunkStore;
    getClaimedLocations(): Map<LocationId, WorldLocation>;
    getConstructors(): {
        MinerManager: { new(): MiningPattern; };
        SpiralPattern: { new(): MiningPattern; };
        SwissCheesePattern: { new(): MiningPattern; };
        TowardsCenterPattern: { new(): MiningPattern; };
        TowardsCenterPatternV2: { new(): MiningPattern; };
    };
    getContract(): DarkForest;
    getContractAPI(): any;
    getContractAddress(): string;
    getContractConstants(): GameManager["contractConstants"];
    getCurrentlyExploringChunk(): Rectangle;
    getDefaultSpaceJunkForPlanetLevel(level: number): number;
    getDiagnostics(): GameManager["diagnostics"];
    getDist(from: LocationId, to: LocationId): number;
    getDistCoords(from: WorldCoords, to: WorldCoords): number;
    getEndTimeSeconds(): number;
    getEnergyArrivingForMove(from: LocationId, to: LocationId, distance: number | undefined, sendEnergy: number, abandoning?: boolean): number;
    getEnergyCurveAtPercent(location: LocationId, percent: number): number;
    getEnergyNeededForMove(from: LocationId, to: LocationId, arrivingEnergy: number, abandoning?: boolean): number;
    getEnergyOfPlayer(player: string): number;
    getEthConnection(): EthConnection;
    getExploredChunks(): Iterable<Chunk>;
    getGameObjects(): GameObjects;
    getHashConfig(): HashConfig;
    getHashesPerSec(): number;
    getHomeCoords(): WorldCoords;
    getHomeHash(): LocationId;
    getLocationOfPlanet(id: LocationId): WorldLocation;
    getMaxMoveDist(location: LocationId, sendingPercent: number): number;
    getMiningPattern(): MiningPattern;
    getMyArtifactMap(): Map<ArtifactId, Artifact>;
    getMyArtifacts(): Artifact[];
    getMyArtifactsUpdated$(): Monomitter<Map<ArtifactId, Artifact>>;
    getMyBalance(): TBigInteger;
    getMyBalance$(): Monomitter<TBigInteger>;
    getMyBalanceEth(): number;
    getMyPlanetMap(): Map<LocationId, Planet>;
    getMyPlanets(): Planet[];
    getMyPlanetsUpdated$(): Monomitter<Map<LocationId, Planet>>;
    getMyScore(): number;
    getNextBroadcastAvailableTimestamp(): number;
    getNextClaimAvailableTimestamp(): number;
    getNotificationsManager();
    getPaused(): boolean;
    getPaused$(): Monomitter<boolean>;
    getPerlinThresholds(): [number, number, number];
    getPlanetLevel(location: LocationId): number;
    getPlanetMap(): Map<LocationId, Planet>;
    getPlanetRarity(): number;
    getPlanetUpdated$(): Monomitter<LocationId>;
    getPlanetWithCoords(coords: WorldCoords): LocatablePlanet;
    getPlanetWithId(location: LocationId): Planet;
    getPlanetsInRange(location: LocationId, sendingPercent: number): Planet[];
    getPlanetsInWorldRectangle(worldX: number, worldY: number, worldWidth: number, worldHeight: number, levels?: number[], planetLevelToRadii?: Map<number, any>, updateIfStale?: boolean): LocatablePlanet[];
    getPlanetsWithIds(location: LocationId): Planet[];
    getPlayer(address: string): Player;
    getPlayerScore(address: string): number;
    getPlayerSpaceJunk(address: string): number;
    getPlayerSpaceJunkLimit(address: string): number;
    // getPrivateKey() // hmm why do we need player's pk?
    getRangeBuff(abandoning: boolean): number;
    getRevealedLocations(): Map<LocationId, RevealedLocation>;
    getSafeMode(): boolean;
    getSignedTwitter(twitter: string): Promise<string>;
    getSilverCurveAtPercent(planet: Planet, percent: number): number;
    getSilverOfPlayer(player: Player): number;
    getSnarkHelper(): SnarkHelper;
    getSpeedBuff(abandoning): number;
    getStalePlanetWithId(location: LocationId): Planet;
    getTemperature(coords: WorldCoords): number;
    getTimeForMove(from: LocationId, to: LocationId, abandoning?: boolean): number;
    getTokenMintEndTimeSeconds(): number;
    getTwitter(address: string): string;
    getUniverseTotalEnergy(): number;
    getUpgrade(branch: number, level: number): Upgrade;
    getWorldRadius(): number;
    getWorldSilver(): number;
    getWormholeFactors(from: LocationId, to: LocationId): { distanceFactor: number; speedFactor: number; };
    getWormholes(): Iterable<Wormhole>;
    hardRefreshArtifact(artifact: ArtifactId): Promise<void>;
    hardRefreshPlanet(location: LocationId): Promise<void>;
    hardRefreshPlayer(address: string): Promise<void>;
    hasJoinedGame(): boolean;
    hasMinedChunk(chunkLocation: Rectangle): boolean;
    initMiningManager(homeCoords: WorldCoords, cores?: number): void;
    isAdmin(): boolean;
    isMining(): boolean;
    isPlanetMineable(planet: Planet): boolean;
    isRoundOver(): boolean;
    joinGame(beforeRetry: (e: Error) => Promise<boolean>): Promise<void>;
    listenForNewBlock(): void;
    loadContract<T>(address: string, abi: any): Promise<T>;
    locationFromCoords(coords: WorldCoords): WorldLocation;
    refreshNetworkHealth(): Promise<void>;
    refreshScoreboard(): Promise<void>;
    refreshServerPlanetStates(locations: LocationId[]): Promise<void>;
    refreshTwitters(): Promise<void>;
    setMinerCores(nCores: number): void;
    setMiningPattern(pattern: MiningPattern): void;
    setSnarkCacheSize(size: number): void;
    softRefreshPlanet(location: LocationId): Promise<void>;
    spaceTypeFromPerlin(perlin: number): SpaceType;
    spaceTypePerlin(coords: WorldCoords, floor: boolean): number;
    startExplore(): void;
    stopExplore(): void;
    timeUntilNextBroadcastAvailable(): number;
    uploadDiagnostics(): Promise<void>;
    waitForPlanet<T>(location: LocationId, predicate: (diff: Diff<Planet>) => T): T;
    
    activateArtifact(location: LocationId, artifact: ArtifactId, wormholeTo?: LocationId): Promise<Transaction<UnconfirmedActivateArtifact>>;
    buyHat(location: LocationId): Promise<Transaction<UnconfirmedBuyHat>>;
    capturePlanet(location: LocationId): Promise<Transaction<UnconfirmedCapturePlanet>>;
    deactivateArtifact(location: LocationId, artifact: ArtifactId): Promise<Transaction<UnconfirmedDeactivateArtifact>>;
    depositArtifact(location: LocationId, artifact: ArtifactId): Promise<Transaction<UnconfirmedDepositArtifact>>;
    findArtifact(location: LocationId): Promise<Transaction<UnconfirmedFindArtifact>>;
    getSpaceships(): Promise<void>;
    getUnconfirmedMoves(): Transaction<UnconfirmedMove>[];
    getUnconfirmedUpgrades(): Transaction<UnconfirmedUpgrade>[];
    getUnconfirmedWormholeActivations(): Transaction<UnconfirmedActivateArtifact>[];
    invadePlanet(location: LocationId): Promise<Transaction<UnconfirmedInvadePlanet>>;
    move(from: LocationId, to: LocationId, forces: number, silver: number, artifact?: ArtifactId, abandoning?: boolean): Promise<Transaction<UnconfirmedMove>>;
    onTxCancelled(tx: Transaction<TxIntent>): void;
    onTxConfirmed(tx: Transaction<TxIntent>): void;
    onTxReverted(tx: Transaction<TxIntent>): void;
    onTxSubmit(tx: Transaction<TxIntent>): void;
    prospectPlanet(location: LocationId): Promise<Transaction<UnconfirmedProspectPlanet>>;
    revealLocation(location: LocationId): Promise<Transaction<UnconfirmedReveal>>;
    submitTransaction<T extends TxIntent>(txIntent: T, overrides?: any): Promise<Transaction<T>>;
    transferOwnership(location: LocationId, newOwner: string): Promise<Transaction<UnconfirmedPlanetTransfer>>;
    upgrade(location: LocationId, branch: number): Promise<Transaction<UnconfirmedUpgrade>>;
    withdrawArtifact(location: LocationId, artifact: ArtifactId): Promise<Transaction<UnconfirmedWithdrawArtifact>>;
    withdrawSilver(location: LocationId, amount: number): Promise<Transaction<UnconfirmedWithdrawSilver>>;

}